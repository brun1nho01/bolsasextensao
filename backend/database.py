from supabase import create_client, Client
import os
from dotenv import load_dotenv
import re
import unicodedata
from difflib import get_close_matches
from collections import defaultdict
from typing import Optional
from datetime import datetime, timezone

# ‚úÖ NOVO: Importa a fun√ß√£o de um local centralizado
from .utils import get_match_key

# Lista de palavras comuns a serem ignoradas na normaliza√ß√£o para compara√ß√£o
STOP_WORDS = {
    'A', 'O', 'E', 'UM', 'UMA', 'DE', 'DO', 'DA', 'EM', 'NO', 'NA', 'COM', 'POR', 'PARA', 'SE',
    'S√ÉO', 'AS', 'OS', 'DOS', 'DAS', 'NOS', 'NAS', 'PELO', 'PELA', 'PRA', 'AO', 'AOS', 'QUE',
    'QUANDO', 'COMO', 'ONDE', 'QUEM', 'QUAL', 'SEU', 'SUA'
}

# Lista de termos espec√≠ficos de editais que podem ser ignorados
EDITAL_TERMS = {
    'EDITAL', 'PROJETO', 'BOLSA', 'PROEX', 'PIBEX', 'EXTENS√ÉO', 'PESQUISA', 'SELE√á√ÉO',
    'BOLSISTA', 'RESULTADO', 'INSCRI√á√ÉO', 'CLASSIFICA√á√ÉO', 'CANDIDATO', 'PROGRAMA', 'ANO',
    'PUBLICO', 'PRIVADO', 'INSTITUCIONAL', 'VOLUNTARIA'
}

class SupabaseManager:
    """
    Gerencia a comunica√ß√£o com o banco de dados Supabase.
    """
    def __init__(self):
        url = os.environ.get("SUPABASE_URL")
        key = os.environ.get("SUPABASE_KEY")
        
        if not url or not key:
            raise ValueError("As vari√°veis de ambiente SUPABASE_URL e SUPABASE_KEY s√£o necess√°rias.")
                        
        try:
            self.client: Client = create_client(url, key)
            # Conex√£o com Supabase estabelecida
        except Exception as e:
            print(f"Erro ao conectar com Supabase: {e}")
            self.client = None

    def _normalize_text_for_db(self, text: str) -> str:
        """
        Normaliza√ß√£o M√çNIMA para salvar no banco: mai√∫sculas e espa√ßos √∫nicos.
        MANT√âM acentos, conectivos e palavras-chave.
        """
        if not isinstance(text, str):
            return ""
        try:
            # Apenas converte para mai√∫sculas e normaliza espa√ßos.
            text_upper = text.upper()
            return " ".join(text_upper.split())
        except Exception:
            return ""

    def _get_project_match_key(self, text: str) -> str:
        """
        Normaliza√ß√£o agressiva APENAS para COMPARA√á√ÉO de projetos.
        Usa a normaliza√ß√£o base e remove stop words e termos de edital.
        """
        if not isinstance(text, str):
            return ""
        # Reutiliza a normaliza√ß√£o base para remover acentos/pontua√ß√£o
        base_normalized_text = get_match_key(text)
        words = base_normalized_text.split()
        filtered_words = [word for word in words if word not in STOP_WORDS and word not in EDITAL_TERMS and not word.isdigit()]
        return " ".join(filtered_words)

    def _normalize_perfil(self, perfil: any) -> str:
        """Garante que o n√∫mero do perfil seja uma string com dois d√≠gitos (ex: '1' -> '01')."""
        return str(perfil).strip().zfill(2) if perfil else None

    def _cleanup_old_available_bolsas(self):
        """
        üßπ NOVA FUNCIONALIDADE: Remove bolsas 'dispon√≠vel' de editais antigos 
        quando um novo edital de inscri√ß√£o √© salvo.
        """
        try:
            # 1. Busca a data do edital mais recente
            latest_edital = self.client.table('editais').select('data_publicacao').order('data_publicacao', desc=True).limit(1).execute()
            
            if not latest_edital.data:
                return 0  # N√£o h√° editais no banco
            
            latest_date = latest_edital.data[0]['data_publicacao']
            
            # 2. Remove bolsas 'dispon√≠vel' de editais anteriores ao mais recente
            cleanup_response = self.client.table('bolsas').delete().eq('status', 'disponivel').neq('edital_data_publicacao', latest_date).execute()
            
            deleted_count = len(cleanup_response.data) if cleanup_response.data else 0
            
            if deleted_count > 0:
                print(f"üßπ LIMPEZA: {deleted_count} bolsa(s) n√£o preenchida(s) de editais antigos foram removidas.")
            
            return deleted_count
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na limpeza de bolsas antigas: {e}")
            return 0

    def _verificar_notificacao_existente(self, edital_id: str, tipo_notificacao: str) -> bool:
        """
        üìã Verifica se j√° existe notifica√ß√£o enviada para este edital+tipo.
        Evita notifica√ß√µes duplicadas.
        """
        try:
            response = self.client.table('notificacoes_enviadas').select('id').eq('edital_id', edital_id).eq('tipo_notificacao', tipo_notificacao).limit(1).execute()
            return len(response.data) > 0
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao verificar notifica√ß√£o existente: {e}")
            return False  # Em caso de erro, permite notificar (fail-safe)
    
    def _enfileirar_notificacao(self, edital_id: str, edital_titulo: str, edital_link: str, tipo_edital: str, tipo_notificacao: str, usuarios: list):
        """
        Enfileira uma notifica√ß√£o para ser processada, em vez de envi√°-la diretamente.
        """
        try:
            # O status padr√£o da tabela agora √© 'pendente', ent√£o n√£o precisamos especific√°-lo
            self.client.table('notificacoes_enviadas').insert({
                'edital_id': edital_id,
                'edital_titulo': edital_titulo,
                'edital_link': edital_link,
                'tipo_edital': tipo_edital,
                'tipo_notificacao': tipo_notificacao,
                'detalhes': { 'usuarios_alvo': usuarios } # Armazena para quem enviar
            }).execute()
            print(f"‚úÖ Notifica√ß√£o para o edital '{edital_titulo}' enfileirada para {len(usuarios)} usu√°rio(s).")
        except Exception as e:
            print(f"‚ùå Erro ao enfileirar notifica√ß√£o: {e}")

    def _buscar_usuarios_por_preferencia(self, modalidade: str) -> list:
        """
        üì± Busca usu√°rios que querem receber notifica√ß√µes deste tipo.
        Se usu√°rio n√£o tem prefer√™ncias, retorna para receber TUDO.
        """
        try:
            # Busca usu√°rios ativos
            response = self.client.table('telegram_alerts').select('telegram_id, preferencias').eq('status', 'ativo').execute()
            
            if not response.data:
                return []
            
            usuarios_filtrados = []
            for usuario in response.data:
                preferencias = usuario.get('preferencias')
                
                # Se n√£o tem prefer√™ncias definidas, recebe TUDO
                if not preferencias:
                    usuarios_filtrados.append(usuario['telegram_id'])
                    continue
                
                # Se tem prefer√™ncias, verifica se est√° ativo para essa modalidade
                if preferencias.get(modalidade) is True:
                    usuarios_filtrados.append(usuario['telegram_id'])
            
            return usuarios_filtrados
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao buscar usu√°rios por prefer√™ncia: {e}")
            # Fallback: retorna todos os ativos (fail-safe)
            try:
                fallback = self.client.table('telegram_alerts').select('telegram_id').eq('status', 'ativo').execute()
                return [u['telegram_id'] for u in fallback.data] if fallback.data else []
            except:
                return []

    def upsert_edital(self, edital_data: dict, edital_url: str):
        """
        Insere ou atualiza um edital de forma transacional usando uma fun√ß√£o RPC no Supabase.
        A l√≥gica de correspond√™ncia fuzzy de projetos √© feita em Python antes de enviar os dados.
        
        üÜï NOVA FUNCIONALIDADE: Remove automaticamente bolsas n√£o preenchidas de editais antigos.
        üì± NOTIFICA√á√ïES INTELIGENTES: S√≥ notifica editais NOVOS, evitando spam.
        """
        if not self.client:
            print("Cliente Supabase n√£o inicializado. Abortando opera√ß√£o.")
            return None

        try:
            # 1. Busca o ID do edital existente ou prepara para criar um novo
            response = self.client.table('editais').select('id').eq('link', edital_url).execute()
            edital_id_antes = response.data[0]['id'] if response.data else None
            is_edital_novo = edital_id_antes is None  # ‚Üê CRUCIAL: Detecta se √© INSERT ou UPDATE

            # 2. Prepara a lista de projetos para o payload final
            projetos_payload = []
            projetos_data = edital_data.get('projetos', [])

            if not projetos_data:
                # Edital sem projetos, salvando apenas edital
                pass
            else:
                # Busca todos os projetos existentes para este edital para fazer o match
                projetos_existentes = []
                if edital_id_antes:
                    res_existentes = self.client.table('projetos').select('id, nome_projeto').eq('edital_id', edital_id_antes).execute()
                    projetos_existentes = res_existentes.data or []
                
                # Cria um mapa para correspond√™ncia fuzzy
                match_map = {self._get_project_match_key(p['nome_projeto']): p for p in projetos_existentes}

                for proj_info in projetos_data:
                    nome_projeto_db = self._normalize_text_for_db(proj_info.get('nome_projeto'))
                    nome_projeto_match_key = self._get_project_match_key(proj_info.get('nome_projeto'))

                    # L√≥gica de Fuzzy Matching para encontrar ID existente
                    matches = get_close_matches(nome_projeto_match_key, list(match_map.keys()), n=1, cutoff=0.85)
                    
                    projeto_id_existente = None
                    if matches:
                        matched_key = matches[0]
                        projeto_existente_obj = match_map[matched_key]
                        projeto_id_existente = projeto_existente_obj['id']
                        # Projeto correspondente encontrado no BD

                    # Normaliza os detalhes das bolsas
                    bolsas_detalhadas = []
                    for bolsa in proj_info.get('detalhe_bolsas', []):
                        bolsas_detalhadas.append({
                            'tipo': bolsa.get('tipo_bolsa'),
                            'remuneracao': bolsa.get('valor_bolsa'),
                            'vagas': bolsa.get('vagas', 1),
                            'numero_perfil': self._normalize_perfil(bolsa.get('numero_perfil')),
                            'requisito': bolsa.get('requisitos')
                        })

                    # Monta o payload para este projeto espec√≠fico
                    projeto_atual = {
                        'id': projeto_id_existente, # Ser√° null se for um projeto novo
                        'nome_projeto': nome_projeto_db,
                        'orientador': self._normalize_text_for_db(proj_info.get('orientador')),
                        'centro': proj_info.get('centro'),
                        'resumo': proj_info.get('resumo'),
                        'detalhe_bolsas': bolsas_detalhadas
                    }
                    projetos_payload.append(projeto_atual)

            # 3. Monta o payload final para a fun√ß√£o RPC
            payload_final = {
                'titulo': edital_data.get('titulo'),
                'link': edital_url,
                'data_fim_inscricao': edital_data.get('data_fim_inscricao'),
                'data_publicacao': edital_data.get('data_publicacao'),
                'data_divulgacao_resultado': edital_data.get('data_divulgacao_resultado'),
                'modalidade': edital_data.get('modalidade', 'extensao'),  # ‚Üê NOVO: Salva modalidade
                'projetos': projetos_payload
            }

            # 4. Chama a fun√ß√£o RPC com o payload completo
            rpc_response = self.client.rpc('handle_edital_upsert', {'edital_payload': payload_final}).execute()

            if rpc_response.data:
                final_edital_id = rpc_response.data
                # Edital salvo com sucesso
                
                # üßπ LIMPEZA AUTOM√ÅTICA: Remove bolsas n√£o preenchidas de editais antigos
                if edital_data.get('etapa') == 'inscricao':  # S√≥ limpa para editais de inscri√ß√£o
                    self._cleanup_old_available_bolsas()
                
                # üîî NOTIFICA√á√ïES TELEGRAM INTELIGENTES via FILA
                # ‚úÖ S√≥ enfileira se for EDITAL NOVO (evita spam)
                if is_edital_novo:
                    try:
                        tipo_edital = edital_data.get('etapa', 'inscricao')
                        modalidade = edital_data.get('modalidade', 'extensao')
                        
                        if modalidade == 'apoio_academico':
                            tipo_notificacao = 'apoio_academico'
                        elif tipo_edital == 'resultado':
                            tipo_notificacao = 'resultado'
                        else:
                            tipo_notificacao = 'extensao'
                        
                        usuarios_interessados = self._buscar_usuarios_por_preferencia(modalidade)
                        
                        if not usuarios_interessados:
                            print(f"‚ÑπÔ∏è [SEM USU√ÅRIOS] Nenhum usu√°rio quer receber '{modalidade}'. N√£o notificando.")
                        else:
                            # Enfileira a notifica√ß√£o em vez de enviar diretamente
                            self._enfileirar_notificacao(
                                edital_id=final_edital_id,
                                edital_titulo=edital_data.get('titulo', 'Novo Edital'),
                                edital_link=edital_url,
                                tipo_edital=tipo_edital,
                                tipo_notificacao=tipo_notificacao,
                                usuarios=usuarios_interessados
                            )
                            
                    except Exception as e:
                        print(f"‚ùå Erro durante a l√≥gica de enfileiramento de notifica√ß√£o: {e}")
                else:
                    print(f"‚ÑπÔ∏è [EDITAL EXISTENTE] Notifica√ß√£o ignorada (edital j√° existia): '{edital_data.get('titulo')}'")
                
                return final_edital_id
            else:
                # Tenta fornecer um erro mais detalhado, se poss√≠vel
                error_message = "A fun√ß√£o RPC n√£o retornou um ID."
                if hasattr(rpc_response, 'error') and rpc_response.error:
                    error_message = f"Erro na RPC: {rpc_response.error.message}"
                raise Exception(error_message)

        except Exception as e:
            print(f"  > ERRO na opera√ß√£o transacional para o edital '{edital_data.get('titulo')}': {e}")
            import traceback
            traceback.print_exc()
            return None

    def atualizar_bolsas_com_resultado(self, aprovados: list, edital_url: str = 'https://uenf.br/editais'):
        """
        üöÄ VERS√ÉO OTIMIZADA: Batch Processing (75x mais r√°pido!)
        
        Antes: 301 queries (1 + 100√ó3)
        Depois: 4 queries (4 SELECTs + 1 batch UPDATE)
        
        Atualiza o status das bolsas para 'preenchida' com base nos resultados.
        Lida com orientadores que podem ter m√∫ltiplos projetos.
        
        Performance:
        - Carrega todos os dados de uma vez
        - Processa matches em mem√≥ria
        - Batch update final
        """
        # Esta fun√ß√£o agora delega diretamente para a vers√£o otimizada.
        # A implementa√ß√£o antiga e mais lenta foi removida.
        return self._atualizar_bolsas_otimizado(aprovados, edital_url)
    
    def _atualizar_bolsas_otimizado(self, aprovados: list, edital_url: str):
        """üöÄ Vers√£o otimizada com batch processing"""
        from database_optimized import atualizar_bolsas_com_resultado_otimizado, _find_best_project_match
        
        # Injeta os m√©todos helper
        self._find_best_project_match = lambda projeto, projetos: _find_best_project_match(self, projeto, projetos)
        
        # Executa vers√£o otimizada
        return atualizar_bolsas_com_resultado_otimizado(self, aprovados, edital_url)
    
    def _atualizar_bolsas_antiga(self, aprovados: list, edital_url: str):
        """Vers√£o antiga (legado, mantida para compatibilidade)"""
        # ... c√≥digo antigo aqui ...
        # üîî NOTIFICA√á√ïES TELEGRAM DE RESULTADO
        # ‚úÖ Verifica se j√° foi notificado antes de enviar
        # ‚úÖ Registra em hist√≥rico
        if bolsas_atualizadas > 0:
            try:
                # Busca o edital_id pelo link
                edital_response = self.client.table('editais').select('id, titulo').eq('link', edital_url).limit(1).execute()
                edital_info = edital_response.data[0] if edital_response.data else None
                
                if edital_info:
                    edital_id = edital_info['id']
                    edital_titulo = edital_info['titulo']
                    
                    # Verifica se j√° notificou resultado para este edital
                    ja_notificou = self._verificar_notificacao_existente(edital_id, 'resultado')
                    
                    if not ja_notificou:
                        from telegram_integration import call_telegram_notifications
                        
                        # Criar t√≠tulo baseado nos aprovados
                        orientadores = list(set([a.get('orientador', '') for a in aprovados if a.get('orientador')]))
                        titulo_resultado = f"Resultado PROEX - {bolsas_atualizadas} bolsa(s) preenchida(s)"
                        
                        if orientadores and len(orientadores) <= 3:
                            titulo_resultado += f" - {', '.join(orientadores[:3])}"
                        
                        print(f"üì± [NOVO RESULTADO] Preparando notifica√ß√£o: {bolsas_atualizadas} aprovados")
                        
                        # Chama o sistema de notifica√ß√µes existente
                        notification_result = call_telegram_notifications(
                            titulo=titulo_resultado,
                            link=edital_url,
                            tipo="resultado"
                        )
                        
                        # Registra no hist√≥rico
                        self._registrar_notificacao_enviada(
                            edital_id=edital_id,
                            edital_titulo=edital_titulo,
                            edital_link=edital_url,
                            tipo_edital='resultado',
                            tipo_notificacao='resultado',
                            resultado=notification_result
                        )
                        
                        print(f"‚úÖ Notifica√ß√£o de resultado enviada: {notification_result.get('status', 'processadas')}")
                    else:
                        print(f"‚ÑπÔ∏è [RESULTADO J√Å NOTIFICADO] Ignorando: '{edital_titulo}'")
                    
            except Exception as e:
                print(f"‚ùå Erro ao enviar notifica√ß√£o de resultado: {e}")
                import traceback
                traceback.print_exc()
        
        return bolsas_atualizadas

    def get_all_orientadores(self) -> list:
        """Busca todos os nomes de orientadores √∫nicos no banco de dados."""
        try:
            response = self.client.table('projetos').select('orientador').execute()
            if response.data:
                # Retorna os nomes como est√£o no banco (j√° normalizados de forma "suave")
                return list(set([item['orientador'] for item in response.data if item.get('orientador')]))
            return []
        except Exception as e:
            print(f"  > Erro ao buscar lista de orientadores: {e}")
            return []

    def get_bolsas_agrupadas_paginated(self, page: int = 1, page_size: int = 10, status: Optional[str] = None, centro: Optional[str] = None, tipo: Optional[str] = None, q: Optional[str] = None, sort: str = 'created_at', order: str = 'desc'):
        """
        üÜï NOVA FUNCIONALIDADE: Busca bolsas AGRUPADAS (mesmo projeto + perfil = 1 card com quantidade)
        """
        try:
            offset = (page - 1) * page_size
            
            # Query para bolsas agrupadas - soma vagas iguais
            query = self.client.table('bolsas_view_agrupada').select('*', count='exact')

            if status and status != 'all':
                query = query.eq('status', status)
            
            if centro and centro != 'all':
                query = query.eq('centro', centro)

            if tipo and tipo != 'all':
                if tipo == 'extensao':
                    # Busca por qualquer tipo que contenha 'Extens√£o' OU 'Discente'
                    query = query.or_('tipo.ilike.%Extens√£o%,tipo.ilike.%Discente%')
                elif tipo == 'UA Superior':
                    # Busca por (UA ou Universidade Aberta) E Superior
                    # Encadeamento de .or_() com .ilike() funciona como AND
                    query = query.or_('tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%').ilike('tipo', '%Superior%')
                elif tipo == 'UA M√©dio':
                    # Busca por (UA ou Universidade Aberta) E (M√©dio ou N√≠vel M√©dio)
                    # A biblioteca n√£o tem um m√©todo .and_(), ent√£o constru√≠mos o filtro manualmente.
                    # Para respeitar a imutabilidade, criamos um novo objeto de par√¢metros com .set()
                    # e o reatribu√≠mos ao construtor da query.
                    filter_string = 'or(tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%),or(tipo.ilike.%M√©dio%,tipo.ilike.%N√≠vel M√©dio%)'
                    query.params = query.params.set('and', f'({filter_string})')
                elif tipo == 'UA Fundamental':
                    # Busca por (UA ou Universidade Aberta) E Fundamental
                    query = query.or_('tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%').ilike('tipo', '%Fundamental%')
            
            if q:
                # Normaliza a query do usu√°rio para ser sem acentos antes de passar para o FTS
                q_normalized = get_match_key(q)
                search_terms = q_normalized.split()
                search_query = " & ".join([f"{term}:*" for term in search_terms])
                query = query.filter('fts', 'fts(portuguese)', search_query)

            # Define quais ordena√ß√µes anulam a prioridade de "dispon√≠vel"
            sort_overrides_status = ['view_count', 'orientador'] # Mantido, se necess√°rio
            
            # ORDENA√á√ÉO PRIM√ÅRIA: Sempre pela ordem customizada de status
            query = query.order('status_order', desc=False)

            # ORDENA√á√ÉO SECUND√ÅRIA: A escolhida pelo usu√°rio
            if sort and order:
                is_descending = order.lower() == "desc"
                query = query.order(sort, desc=is_descending)

            # Pagina√ß√£o
            start_idx = (page - 1) * page_size
            end_idx = start_idx + page_size - 1
            query = query.range(start_idx, end_idx)
            
            response = query.execute()
            
            bolsas = response.data
            total_count = response.count if response.count is not None else 0
            total_pages = (total_count + page_size - 1) // page_size

            # üîß CALCULAR TOTAIS COM TODOS OS DADOS (n√£o s√≥ da p√°gina atual)
            try:
                # Query separada para calcular totais gerais  
                all_query = self.client.table('bolsas_view_agrupada').select('vagas_total,status')
                
                # Aplicar os mesmos filtros da query principal
                if status and status != 'all':
                    all_query = all_query.eq('status', status)
                if centro and centro != 'all':
                    all_query = all_query.eq('centro', centro)  
                if tipo and tipo != 'all':
                    if tipo == 'extensao':
                        all_query = all_query.or_('tipo.ilike.%Extens√£o%,tipo.ilike.%Discente%')
                    elif tipo == 'UA Superior':
                        all_query = all_query.or_('tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%').ilike('tipo', '%Superior%')
                    elif tipo == 'UA M√©dio':
                        filter_string = 'or(tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%),or(tipo.ilike.%M√©dio%,tipo.ilike.%N√≠vel M√©dio%)'
                        all_query.params = all_query.params.set('and', f'({filter_string})')
                    elif tipo == 'UA Fundamental':
                        all_query = all_query.or_('tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%').ilike('tipo', '%Fundamental%')
                if q:
                    q_normalized = get_match_key(q)
                    search_terms = q_normalized.split()
                    search_query = " & ".join([f"{term}:*" for term in search_terms])
                    all_query = all_query.filter('fts', 'fts(portuguese)', search_query)
                
                all_response = all_query.execute()
                all_bolsas = all_response.data or []
                
                # Calcular totais com TODOS os dados filtrados
                total_vagas = sum(bolsa.get('vagas_total', 1) for bolsa in all_bolsas)
                vagas_preenchidas = sum(
                    bolsa.get('vagas_total', 1) for bolsa in all_bolsas 
                    if bolsa.get('status') == 'preenchida'
                )
                
            except Exception as calc_error:
                print(f"‚ö†Ô∏è Erro ao calcular totais Python: {calc_error}")
                # Fallback: calcular s√≥ com dados da p√°gina
                total_vagas = sum(bolsa.get('vagas_total', 1) for bolsa in bolsas)
                vagas_preenchidas = sum(
                    bolsa.get('vagas_total', 1) for bolsa in bolsas 
                    if bolsa.get('status') == 'preenchida'
                )

            return {
                "bolsas": bolsas,
                "total": total_count,
                "page": page,
                "page_size": page_size,
                "total_pages": total_pages,
                "agrupadas": True,  # Indica que s√£o bolsas agrupadas
                "total_vagas": total_vagas,  # üÜï Total de vagas (soma de TODOS os dados)
                "vagas_preenchidas": vagas_preenchidas  # üÜï Vagas preenchidas (soma de TODOS os dados)
            }
        except Exception as e:
            print(f"  > Erro ao buscar bolsas agrupadas: {e}")
            # Fallback para m√©todo n√£o-agrupado se der erro
            return self.get_bolsas_paginated(page, page_size, status, centro, tipo, q, sort, order)

    def get_bolsas_paginated(self, page: int = 1, page_size: int = 10, status: Optional[str] = None, centro: Optional[str] = None, tipo: Optional[str] = None, q: Optional[str] = None, sort: str = 'created_at', order: str = 'desc'):
        """
        M√©todo ORIGINAL mantido como fallback - busca bolsas individuais.
        """
        try:
            offset = (page - 1) * page_size
            
            # A query base agora pede a contagem total de itens que correspondem ao filtro
            query = self.client.table('bolsas_view').select('*', count='exact')

            if status and status != 'all':
                query = query.eq('status', status)
            
            if centro and centro != 'all':
                query = query.eq('centro', centro)

            if tipo and tipo != 'all':
                if tipo == 'extensao':
                    # Busca por qualquer tipo que contenha 'Extens√£o' OU 'Discente'
                    query = query.or_('tipo.ilike.%Extens√£o%,tipo.ilike.%Discente%')
                elif tipo == 'UA Superior':
                    # Busca por (UA ou Universidade Aberta) E Superior
                    # Encadeamento de .or_() com .ilike() funciona como AND
                    query = query.or_('tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%').ilike('tipo', '%Superior%')
                elif tipo == 'UA M√©dio':
                    # Busca por (UA ou Universidade Aberta) E (M√©dio ou N√≠vel M√©dio)
                    # A biblioteca n√£o tem um m√©todo .and_(), ent√£o constru√≠mos o filtro manualmente.
                    # Para respeitar a imutabilidade, criamos um novo objeto de par√¢metros com .set()
                    # e o reatribu√≠mos ao construtor da query.
                    filter_string = 'or(tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%),or(tipo.ilike.%M√©dio%,tipo.ilike.%N√≠vel M√©dio%)'
                    query.params = query.params.set('and', f'({filter_string})')
                elif tipo == 'UA Fundamental':
                    # Busca por (UA ou Universidade Aberta) E Fundamental
                    query = query.or_('tipo.ilike.%UA%,tipo.ilike.%Universidade Aberta%').ilike('tipo', '%Fundamental%')
            
            if q:
                # Normaliza a query do usu√°rio para ser sem acentos antes de passar para o FTS
                q_normalized = get_match_key(q)
                search_terms = q_normalized.split()
                search_query = " & ".join([f"{term}:*" for term in search_terms])
                query = query.filter('fts', 'fts(portuguese)', search_query)

            # Define quais ordena√ß√µes anulam a prioridade de "dispon√≠vel"
            sort_overrides_status = ['view_count', 'orientador'] # Mantido, se necess√°rio
            
            # ORDENA√á√ÉO PRIM√ÅRIA: Sempre pela ordem customizada de status
            query = query.order('status_order', desc=False)

            # ORDENA√á√ÉO SECUND√ÅRIA: A escolhida pelo usu√°rio
            if sort and order:
                is_descending = order.lower() == "desc"
                query = query.order(sort, desc=is_descending)

            # Pagina√ß√£o
            start_idx = (page - 1) * page_size
            end_idx = start_idx + page_size - 1
            query = query.range(start_idx, end_idx)
            
            response = query.execute()
            
            bolsas = response.data
            total_count = response.count if response.count is not None else 0
            total_pages = (total_count + page_size - 1) // page_size

            return {
                "bolsas": bolsas,
                "total": total_count,
                "page": page,
                "page_size": page_size,
                "total_pages": total_pages,
                "agrupadas": False  # Indica que s√£o bolsas individuais
            }
        except Exception as e:
            print(f"  > Erro ao buscar bolsas paginadas: {e}")
            return {
                "bolsas": [],
                "total": 0,
                "page": page,
                "page_size": page_size,
                "total_pages": 0,
                "agrupadas": False
            }

    def get_bolsa(self, bolsa_id: str):
        """Busca uma √∫nica bolsa pelo seu ID usando a view."""
        try:
            return self.client.table('bolsas_view').select('*').eq('id', bolsa_id).single().execute().data
        except Exception as e:
            print(f"  > Erro ao buscar bolsa por ID: {e}")
            return None

    def get_projetos(self, page: int = 1, page_size: int = 10):
        """Busca projetos com pagina√ß√£o."""
        try:
            offset = (page - 1) * page_size
            return self.client.table('projetos').select('*').order('created_at', desc=True).range(offset, offset + page_size - 1).execute().data
        except Exception as e:
            print(f"  > Erro ao buscar projetos: {e}")
            return []

    def get_projeto(self, projeto_id: str):
        """Busca um √∫nico projeto pelo seu ID."""
        try:
            return self.client.table('projetos').select('*').eq('id', projeto_id).single().execute().data
        except Exception as e:
            print(f"  > Erro ao buscar projeto por ID: {e}")
            return None

    def get_editais(self, page: int = 1, page_size: int = 10):
        """Busca editais com pagina√ß√£o."""
        try:
            offset = (page - 1) * page_size
            # Garante que 'data_publicacao', 'data_divulgacao_resultado' e 'modalidade' sejam retornados
            query = self.client.table('editais').select(
                'id, titulo, link, data_fim_inscricao, created_at, data_publicacao, data_divulgacao_resultado, modalidade'
            ).order('data_publicacao', desc=True).range(offset, offset + page_size - 1)
            
            return query.execute().data
        except Exception as e:
            print(f"  > Erro ao buscar editais: {e}")
            return []

    def get_edital(self, edital_id: str):
        """Busca um √∫nico edital pelo seu ID."""
        try:
            # Garante que 'data_publicacao', 'data_divulgacao_resultado' e 'modalidade' sejam retornados
            return self.client.table('editais').select(
                'id, titulo, link, data_fim_inscricao, created_at, data_publicacao, data_divulgacao_resultado, modalidade'
            ).eq('id', edital_id).single().execute().data
        except Exception as e:
            print(f"  > Erro ao buscar edital por ID: {e}")
            return None

    def increment_view_count(self, bolsa_id: str):
        """Chama a fun√ß√£o RPC no Supabase para incrementar o contador de views."""
        try:
            self.client.rpc('increment_view_count', {'bolsa_id_param': bolsa_id}).execute()
        except Exception as e:
            # N√£o trava a aplica√ß√£o se o contador falhar, apenas loga o erro
            print(f"  > Erro ao incrementar view count para bolsa {bolsa_id}: {e}")

    def get_ranking_bolsas(self, limit: int = 10):
        """Busca as bolsas mais vistas (ranking)."""
        try:
            return self.client.table('bolsas_view').select('*').order('view_count', desc=True).limit(limit).execute().data
        except Exception as e:
            print(f"  > Erro ao buscar ranking de bolsas: {e}")
            return []

    def get_latest_edital_date(self):
        """Busca a data de publica√ß√£o mais recente de um edital no banco."""
        try:
            # Busca apenas a data de publica√ß√£o, ordena da mais nova para a mais antiga, e pega apenas a primeira.
            response = self.client.table('editais').select('data_publicacao').order('data_publicacao', desc=True).limit(1).single().execute()
            if response.data and response.data.get('data_publicacao'):
                return response.data.get('data_publicacao')
            return None
        except Exception as e:
            # √â normal n√£o encontrar nada se o banco estiver vazio, ent√£o n√£o logamos como um erro grave.
            print(f"  > Info: N√£o foi poss√≠vel buscar a data do √∫ltimo edital (pode ser a primeira execu√ß√£o): {e}")
            return None

    def get_metadata(self) -> dict:
        """Busca todos os metadados da aplica√ß√£o."""
        try:
            response = self.client.table('metadata').select('key, value').execute()
            if response.data:
                # Transforma a lista de objetos em um √∫nico dicion√°rio
                return {item['key']: item['value'] for item in response.data}
            return {}
        except Exception as e:
            print(f"  > Erro ao buscar metadados: {e}")
            return {}

    def update_last_data_update(self, timestamp: str):
        """Atualiza o timestamp da √∫ltima atualiza√ß√£o de dados."""
        try:
            self.client.table('metadata').update({'value': timestamp}).eq('key', 'last_data_update').execute()
        except Exception as e:
            print(f"  > Erro ao atualizar o timestamp de last_data_update: {e}")

